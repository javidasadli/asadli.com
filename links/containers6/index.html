<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-114450519-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-114450519-3');
    </script>

    <title>My Notes</title>
  
    <style>
    * {
      font-size: 1rem;
      font-family: sans-serif;
    }
    pre {
      background-color: #ddd;
      padding: 1em;
      overflow-y: auto;
    }
    p, li { line-height: 1.5em; }
    </style>
  </head>      
  <body>
    <div style="margin: 0 auto; max-width: 45em;">
      <nav>
        <a href="/">Home</a> |
        <a href="/blog">Blog</a> |
        <a href="/links/">Notes</a> |
        <a href="/watch/">Video</a> |
        <a href="/contact/">Contact</a>
      </nav>
      <hr />
          
      <article>
  <header>
    <h1 style="color:firebrick; border-bottom: 1px solid; padding: 5px 0;">
      Patrick Scott [GDD] Byzantine Generals

      
        <small style="display: block; text-align: right; color: black; font-weight: normal;">
          

          

          
            29 November 2018
          
        </small>
      

    </h1>
  </header>

  <div>
    <div id="x_text-44" class="x_editableElement x_de-editing-element x_de-editing-now" style="padding-top: 20px;">
      <div class="x_ce">The general <em>consensus</em> when it comes to scaling is that you can do so in two ways.
      <div>&nbsp;</div>
      <div>
      <div>&nbsp;</div>
      <div>Horizontally, or Vertically.</div>
      <div>&nbsp;</div>
      <div>This is what most people will tell you. I actually think it&rsquo;s three ways, as sharding is a scaling strategy as well, but that&rsquo;s a topic for another time.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Vertical scaling is probably how you&rsquo;ve gone through your life with personal computers and/or laptops.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>You bought one and eventually you needed more power.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Adding more RAM or CPU or hard drive space gives you that power. You use &ldquo;Vertical Scaling&rdquo; when you need more power on your machine.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>The other way to scale, is by adding more machines. This is called &ldquo;Horizontal Scaling&rdquo;.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>This introduces different complexities.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>You&rsquo;ve now entered the realm of distributed computing and distributed systems.</div>
      <div>&nbsp;</div>
      <div>Realities of production systems.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Welcome.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>I want to introduce a popular thought experiment from history, applied to computer science as a metaphor, to help in understanding this problem.</div>
      <div>&nbsp;</div>
      <div>This is known as the "Byzantine Generals&rdquo; problem.</div>
      <div>&nbsp;</div>
      <div>I spent hours looking through YouTube clips and found this one, short (about 2 minutes) video on youtube which did a great job explaining the problem in an easy to understand and visualize way:</div>
      <div>&nbsp;</div>
      <div><a id="x_link-1988-358" class="" style="text-decoration: underline;" href="http://url5112.cloudnative.institute/wf/click?upn=4Sygo-2FhtoXHKofCMapr-2B0naRXF15Tzb3ssQF5gj6v-2FIL0FesM3rYxqNqDlA6XzkLL7CFzJT0alAh-2BJHxuDwVGx2EH657Z-2BiRq5eMd0F7BzNDjWYTIu9LCFedNyaZdThHXmWenqbkjwprqdCCcPIku2ma8-2BYSr1xNyreyNkO-2FDbMzc5KYkraFtFUFtaLFwuEGuz-2BxB54jVhBPXHiRYV6jn-2FTVveTqS6Dj-2BfJRXuacJO1XxZt7eBXHH-2FTYExTOMdzTsQ8ZJyoFo1ZeYdcw-2BdT09-2FhQntaY-2FCjPHv4-2BZqxKHeRHRNDKETuxcJn1Tn2eYXPrmoIyXsnLHQDGZcKnm1YRO-2BwoCB3EFySTjV90ePbxVVIEp2N8LvarQiA9S0LG-2BEjS_Sfz4jTq6iPdK8tCQJQNbOMz2EFd1jXUpOlaUJAcS8dB-2BqqdK9eP2FrbY6oq0XrC9q1t7vH6QAmU3NKy2FxHM-2BDmjBqAvyBAalyZ-2F0jAOtomaHaCEengzTin3xvPPO6TSDJfBrpGFGspQrjm7cCP-2BIUBiBV4neNsiKiHz2DlY8mlnCUvhxIouHC5O2q-2F-2FjXFim9rCVHg25d6h6ftFOdAv0rHVrIv8G6Opg6ATQMrhRSU-3D" target="_blank" rel="noopener noreferrer" data-auth="NotApplicable">Byzantine General&rsquo;s Problem - YouTube</a></div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Go ahead and watch it now.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>&hellip;</div>
      <div>&nbsp;</div>
      <div>&hellip;</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Back?</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Ok.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Needless to say, it&rsquo;s quite a complicated problem.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div><strong>Generally the way to solve unsolvable problems is to introduce constraints, which make the results acceptable, while still not perfect.</strong></div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Over the years, technology has been introduced, developed, refined, and iterated on to ease the burden of working with distributed systems, and work towards solving problems such as these.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Essentially, we want to find a way to work with many computers, <em>as if they were one.</em></div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>I specifically want to talk about a way to do just this, known as &ldquo;clustering&rdquo;.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>A cluster is a group of servers that all act in unison as if they were one. They are a solution to horizontal scaling.</div>
      <div>&nbsp;</div>
      <div>The cluster of computers needs to be able to reach consensus on an agreed upon state.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>With the advent of Blockchain the ideas of clusters are becoming more mainstream. Even many in the general public understand that the blockchain is decentralized, and made up of many different servers working together, and making decisions based on the consensus of the majority.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Ethereum is even often described as a &ldquo;global computer&rdquo;.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>The container orchestrators,&nbsp;<strong>Kubernetes</strong> and <strong>Docker Swarm,</strong> do a lot of things &ndash; one of the core essential pieces, is allowing you to group servers together in a private cluster.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>This means that each orchestrator is aware of what other computers, known as "Nodes", make up the cluster, and what resources are available on each Node (memory, CPU, etc).</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>When given tasks or services to run, they evaluate the available resources on each Node in the cluster, and decide where the best place to run that task is based on it&rsquo;s requirements.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>It schedules tasks essentially the same way your computer or smart phone schedules tasks, except instead of being able to only schedule tasks on a single machine, it schedules tasks on a cluster which is made up of many machines.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>An important part of any cluster is consensus. There are different types of consensus algorithms, Blockchain being one of them, with different requirements for agreeing upon the state.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>The important thing is that the Nodes need to agree upon the state.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Docker Swarm and Kubernetes both work very similarly in regard to their consensus algorithm.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>They use one known as &ldquo;Raft&rdquo;.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Raft has become very popular over the past few years due to it&rsquo;s power and ease of implementation.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>&ldquo;Paxos&rdquo; is another infamous consensus algorithm you may have heard of. It is renowned for being very technical and difficult to understand and implement.</div>
      <div>&nbsp;</div>
      <div>I once met Greg Young, of DDD and CQRS/ES fame, and he told me I basically wouldn't know anything as an engineer until I've mastered Paxos. I haven't, but maybe someday :)</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>With either, though, the more Nodes in the system, the more parties need to agree on a state.</div>
      <div>&nbsp;</div>
      <div>Meaning the algorithm becomes less efficient with more Nodes - also because more data needs to be replicated to more places. This is why people are all like "the blockchain can't scale!" and other people are like "we'll figure it out... probably..."</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>To deal with this in container orchestration cluster land, <em>there are only a subset of nodes that are responsible for reaching consensus.&nbsp;</em></div>
      <div>&nbsp;</div>
      <div>The nodes in this subset are &ldquo;<strong>Manager</strong>&rdquo; nodes. Once the majority of "managers" reach an agreement on the state, they then schedule tasks on &ldquo;Worker&rdquo; nodes.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>It&rsquo;s generally recommended to run a max of 5 manager nodes for this reason, and a minimum of 3.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>The reason being, if too many manager nodes are lost at once, it will be impossible for the cluster to reach a majority consensus, and manual recovery command will need to be run.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>When running three managers, you can safely lose 1 entire manager Node without issues, as the 2 remaining managers will still be in consensus. It is not safe to remain in this state, however, the orchestrator will still know what state it SHOULD be in, and will spin up a new manager node to replace the lost node.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>If you are running 5 managers, you can safely lose 2 without losing consensus.</div>
      <div>&nbsp;</div>
      <div>Although it's not important for our discussion, a large difference with Blockchain is essentially ALL nodes are managers, rather than a small subset.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>This was a lot to take in for today.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Don&rsquo;t worry about it too much, you just need to know at a high level that there is a consensus algorithm that is operating in the background of your cluster, making sure all managers nodes agree upon the <strong>state</strong> of the cluster, so you need to run enough of them to have redundancy.</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>And just to elaborate a bit on what that <strong>state</strong> is, it is the description of how many nodes are in the cluster, what services, volumes, secrets, configs, and any other cloud primitives make up the cluster.</div>
      <div>&nbsp;</div>
      <div>What do you think would happen if you were able to describe the&nbsp;<strong>state</strong> <em>that you want to exist </em>to the orchestrator by inputting it as a config?</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div><strong>The docker-compose files we used earlier for development orchestration were examples of this.</strong> They described the desired state of services, networks, and volumes that should be running in a YAML configuration file.</div>
      <div>&nbsp;</div>
      <div>---</div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div><strong>So can we use docker-compose to describe the production state, or do we need to use something else?</strong></div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Join me tomorrow as we dive deeper.</div>
      </div>
      </div>
      </div>
      <div id="x_text-24826" class="x_editableElement" style="padding-top: 10px; font-size: 18px; font-family: Georgia, serif, serif, EmojiFont;">
      <div class="x_ce"><strong><em>Patrick &ldquo;Byzantine General&rdquo; Scott</em></strong></div>
      </div>
      <div id="x_text-56888" class="x_editableElement" style="padding-top: 20px; display: block;">
      <div class="x_ce">
      <div>
      <div>P.S. Just in case you&rsquo;re feeling overwhelmed I just want to reiterate the fact that you do NOT need to learn the details of how consensus algorithms work to run either of these orchestrators. It is important however, to understand at a high level what's happening behind the scenes to avoid setting up your cluster incorrectly.</div>
      </div>
      <div>&nbsp;</div>
      <div>&nbsp;</div>
      <div>Btw, can you think of other applications you have used that might use a consensus algorithm under the hood? They are all around you! Let me know!</div>
      </div>
      </div>
      <p>&nbsp;</p>


    <hr />
    


  </div>
</article>


      <hr />
      <footer>
        <p>&copy; Javid Asadli 2018</p>
      </footer>
    </div>
  </body>
</html>
